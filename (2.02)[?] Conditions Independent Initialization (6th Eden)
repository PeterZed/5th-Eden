/*
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

Initializes a cell's conditions' values, independent of its neighbors'.

? Still ongoing development until I work out how I want all of the conditions to act, but otherwise
functions. The initialization of sensoryConds and enviroConds are not yet determined, but I might do them
the same as the cyclicalConds.
*/
Cell.prototype.condsIndInit = function() {
  for (var cond in this.needsConds) {
    for (var prop in this.needsConds[cond]) {
      var targetCond = this.needsConds[cond][prop];
    
      targetCond.level = Math.floor(Math.random() * 10001) / 100;
      targetCond.flux = Math.floor(Math.random() * 1001) / 100;
      
      targetCond.dynamism = Math.floor(Math.random() * 10001) / 100;
      targetCond.dynamismFlux = Math.floor(Math.random() * 1001) / 100;
    }
  }
  
  for (var cond in this.sensoryConds) {
    for (var prop in this.sensoryConds[cond]) {
      var targetCond = this.sensoryConds[cond][prop];
    
      targetCond.level = Math.floor(Math.random() * 10001) / 100;
      targetCond.flux = Math.floor(Math.random() * 1001) / 100;
      
      targetCond.dynamism = Math.floor(Math.random() * 10001) / 100;
      targetCond.dynamismFlux = Math.floor(Math.random() * 1001) / 100;
    }
  }
  
  for (var cond in this.enviroConds) {
    for (var prop in this.enviroConds[cond]) {
      var targetCond = this.enviroConds[cond][prop];
    
      targetCond.level = Math.floor(Math.random() * 10001) / 100;
      targetCond.flux = Math.floor(Math.random() * 1001) / 100;
      
      targetCond.dynamism = Math.floor(Math.random() * 10001) / 100;
      targetCond.dynamismFlux = Math.floor(Math.random() * 1001) / 100;
    }
  }
  
  this.initialized = true;
};
