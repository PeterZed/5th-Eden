/*
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

Determines for every relevant property of a cell if it undergoes a fluctuation this tick.

? If this slows down ticks by too much, I can always make dynamism a hard value for number of turns
between fluctuations instead of an average value (which requires more probability rolls).
*/
Cell.prototype.condsFluxDet = function() {
  for (var set in this.conds) { // Cycles each condition set: physicalState, sensory, enviro
    for (var cond in this.conds[set]) { // Cycles each condition of each condition set
      for (var prop in this.conds[set][cond]) { // Cycles every property of each condition
        var targetCond = this.conds[set][cond][prop]; // Just shortens the prop value's reference
  
        // Makes prob roll against appropriate dynamism to determine if value fluxes this tick
        if (this.condsFluxCheck(targetCond.dynamism)) { // Makes probability roll
          targetCond.level += this.condsFlux(0, targetCond.flux); // 
        }
        if (this.condsFluxCheck(targetCond.dynamism)) {
          targetCond.flux += this.condsFlux(0, targetCond.surge);
        }
      
        if (this.condsFluxCheck(this.metaDynamism.level)) {
          targetCond.dynamism += this.condsFlux(0, targetCond.dynamismFlux);
        }
        if (this.condsFluxCheck(this.metaDynamism.level)) {
          targetCond.dynamismFlux += this.condsFlux(0, targetCond.dynamismSurge);
        }
      
        this.eden.hundredthsRounding(targetCond);
        // Checks if level, flux, dynamism, and dynamismFlux are within limits after the mod
        this.eden.checkLimits(targetCond);
      }
    }
  }
};
